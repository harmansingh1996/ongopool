{"version":3,"file":"bookingPolicyService-B42_nGBE.js","sources":["../../src/lib/bookingPolicyService.ts"],"sourcesContent":["import { supabase } from './supabase';\nimport { PaymentHoldService } from './paymentHoldService';\n\nexport interface CancellationResult {\n  success: boolean;\n  refunded: boolean;\n  reason?: string;\n  error?: string;\n  refundAmount?: number;\n  cancellationFee?: number;\n}\n\nexport interface CancellationEligibility {\n  canCancel: boolean;\n  reason: string;\n  refundAmount?: number;\n  cancellationFee?: number;\n  timeToRide?: number; // hours until ride departure\n}\n\n/**\n * Booking Policy Service\n * Handles cancellation policies, automatic refunds, and no-cancellation enforcement\n */\nexport class BookingPolicyService {\n\n  /**\n   * Check if a booking can be cancelled and calculate refund amount\n   */\n  static async checkCancellationEligibility(\n    bookingId: number, \n    userId: string\n  ): Promise<CancellationEligibility> {\n    try {\n      const { data: booking, error } = await supabase\n        .from('ride_bookings')\n        .select(`\n          *,\n          rides (*)\n        `)\n        .eq('id', bookingId)\n        .single();\n\n      if (error || !booking) {\n        return {\n          canCancel: false,\n          reason: 'Booking not found'\n        };\n      }\n\n      // Check if user is passenger or driver\n      const isPassenger = booking.passenger_id === userId;\n      const isDriver = booking.rides.driver_id === userId;\n\n      if (!isPassenger && !isDriver) {\n        return {\n          canCancel: false,\n          reason: 'You are not authorized to cancel this booking'\n        };\n      }\n\n      // Calculate time until departure\n      const now = new Date();\n      const departureTime = new Date(booking.rides.departure_time);\n      const hoursUntilDeparture = (departureTime.getTime() - now.getTime()) / (1000 * 60 * 60);\n\n      // Check current booking status\n      if (booking.status === 'cancelled') {\n        return {\n          canCancel: false,\n          reason: 'Booking is already cancelled'\n        };\n      }\n\n      if (booking.status === 'rejected') {\n        return {\n          canCancel: false,\n          reason: 'Booking was already rejected'\n        };\n      }\n\n      // For pending bookings - full refund always allowed\n      if (booking.status === 'pending') {\n        return {\n          canCancel: true,\n          reason: 'Pending booking can be cancelled with full refund',\n          refundAmount: booking.total_amount,\n          cancellationFee: 0,\n          timeToRide: hoursUntilDeparture\n        };\n      }\n\n      // For confirmed bookings - apply cancellation policy based on time\n      if (booking.status === 'confirmed') {\n        const refundData = this.calculateRefundAmount(booking.total_amount, hoursUntilDeparture);\n        \n        // Special handling for past rides\n        if (hoursUntilDeparture <= -2) {\n          return {\n            canCancel: false,\n            reason: 'Cannot cancel completed rides'\n          };\n        }\n\n        return {\n          canCancel: true,\n          reason: this.getCancellationPolicyMessage(hoursUntilDeparture),\n          refundAmount: refundData.refundAmount,\n          cancellationFee: refundData.cancellationFee,\n          timeToRide: hoursUntilDeparture\n        };\n      }\n\n      return {\n        canCancel: false,\n        reason: 'Booking cannot be cancelled at this time'\n      };\n\n    } catch (error) {\n      console.error('Error checking cancellation eligibility:', error);\n      return {\n        canCancel: false,\n        reason: 'Error checking cancellation eligibility'\n      };\n    }\n  }\n\n  /**\n   * Calculate refund amount based on cancellation policy\n   */\n  private static calculateRefundAmount(totalAmount: number, hoursUntilDeparture: number): {\n    refundAmount: number;\n    cancellationFee: number;\n  } {\n    let refundPercentage: number;\n\n    if (hoursUntilDeparture >= 12) {\n      // 12+ hours before departure: No cancellation fee\n      refundPercentage = 100;\n    } else if (hoursUntilDeparture >= 6) {\n      // 6-12 hours before departure: 25% cancellation fee\n      refundPercentage = 75;\n    } else if (hoursUntilDeparture >= 2) {\n      // 2-6 hours before departure: 50% cancellation fee\n      refundPercentage = 50;\n    } else if (hoursUntilDeparture >= 0) {\n      // Less than 2 hours before departure: 75% cancellation fee\n      refundPercentage = 25;\n    } else {\n      // After departure time (no-show): 100% cancellation fee\n      refundPercentage = 0;\n    }\n\n    const refundAmount = Math.round((totalAmount * refundPercentage / 100) * 100) / 100;\n    const cancellationFee = Math.round((totalAmount - refundAmount) * 100) / 100;\n\n    return { refundAmount, cancellationFee };\n  }\n\n  /**\n   * Get user-friendly cancellation policy message\n   */\n  private static getCancellationPolicyMessage(hoursUntilDeparture: number): string {\n    if (hoursUntilDeparture >= 12) {\n      return 'Free cancellation - No cancellation fee (12+ hours before departure)';\n    } else if (hoursUntilDeparture >= 6) {\n      return 'Cancellation fee: 25% of ride cost (6-12 hours before departure)';\n    } else if (hoursUntilDeparture >= 2) {\n      return 'Cancellation fee: 50% of ride cost (2-6 hours before departure)';\n    } else if (hoursUntilDeparture >= 0) {\n      return 'Cancellation fee: 75% of ride cost (less than 2 hours before departure)';\n    } else {\n      return 'No refund available for completed rides';\n    }\n  }\n\n  /**\n   * Cancel a booking with automatic refund processing\n   */\n  static async cancelBooking(bookingId: number, userId: string): Promise<CancellationResult> {\n    try {\n      // First check if cancellation is allowed\n      const eligibility = await this.checkCancellationEligibility(bookingId, userId);\n      \n      if (!eligibility.canCancel) {\n        return {\n          success: false,\n          refunded: false,\n          error: eligibility.reason\n        };\n      }\n\n      // Get booking details for processing\n      const { data: booking, error: bookingError } = await supabase\n        .from('ride_bookings')\n        .select(`\n          *,\n          rides (*)\n        `)\n        .eq('id', bookingId)\n        .single();\n\n      if (bookingError || !booking) {\n        return {\n          success: false,\n          refunded: false,\n          error: 'Booking not found'\n        };\n      }\n\n      // Process refund based on status and time\n      let refundResult = null;\n      if (booking.status === 'pending') {\n        // Full refund for pending bookings\n        refundResult = await PaymentHoldService.refundPaymentHold(\n          bookingId, \n          'passenger_cancelled'\n        );\n      } else if (booking.status === 'confirmed' && eligibility.refundAmount! > 0) {\n        // Partial refund for confirmed bookings based on policy\n        refundResult = await this.processPartialRefund(\n          bookingId, \n          eligibility.refundAmount!,\n          eligibility.cancellationFee!\n        );\n      }\n\n      // Update booking status\n      const { error: updateError } = await supabase\n        .from('ride_bookings')\n        .update({ \n          status: 'cancelled',\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', bookingId);\n\n      if (updateError) {\n        console.error('Error updating booking status:', updateError);\n        return {\n          success: false,\n          refunded: false,\n          error: 'Failed to update booking status'\n        };\n      }\n\n      // Send cancellation message to chat\n      await this.sendCancellationMessage(\n        bookingId, \n        booking.ride_id, \n        userId, \n        'passenger_cancelled',\n        eligibility.refundAmount,\n        eligibility.cancellationFee\n      );\n\n      return {\n        success: true,\n        refunded: (eligibility.refundAmount! > 0),\n        refundAmount: eligibility.refundAmount,\n        cancellationFee: eligibility.cancellationFee,\n        reason: 'Booking cancelled successfully'\n      };\n\n    } catch (error) {\n      console.error('Error cancelling booking:', error);\n      return {\n        success: false,\n        refunded: false,\n        error: 'An error occurred while cancelling the booking'\n      };\n    }\n  }\n\n  /**\n   * Process partial refund for confirmed bookings\n   */\n  private static async processPartialRefund(\n    bookingId: number,\n    refundAmount: number,\n    cancellationFee: number\n  ): Promise<any> {\n    try {\n      // Create payment record for the partial refund\n      const { data: booking } = await supabase\n        .from('ride_bookings')\n        .select('passenger_id, total_amount')\n        .eq('id', bookingId)\n        .single();\n\n      if (!booking) return null;\n\n      // Insert refund payment record\n      const { data: payment, error } = await supabase\n        .from('payments')\n        .insert({\n          booking_id: bookingId,\n          user_id: booking.passenger_id,\n          amount: -refundAmount, // Negative amount for refund\n          currency: 'USD',\n          status: 'refunded',\n          payment_method: 'refund',\n          refund_reason: 'passenger_cancelled_with_fee',\n          refunded_at: new Date().toISOString(),\n          created_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error creating refund payment record:', error);\n      }\n\n      // Create cancellation fee record if applicable\n      if (cancellationFee > 0) {\n        await supabase\n          .from('payments')\n          .insert({\n            booking_id: bookingId,\n            user_id: booking.passenger_id,\n            amount: cancellationFee,\n            currency: 'USD',\n            status: 'captured',\n            payment_method: 'cancellation_fee',\n            created_at: new Date().toISOString()\n          });\n      }\n\n      return payment;\n    } catch (error) {\n      console.error('Error processing partial refund:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Request cancellation exception for edge cases\n   */\n  static async requestCancellationException(\n    bookingId: number, \n    userId: string, \n    justification: string\n  ): Promise<{ success: boolean; ticketId?: number; error?: string }> {\n    try {\n      const { data: ticket, error } = await supabase\n        .from('support_tickets')\n        .insert({\n          user_id: userId,\n          subject: `Cancellation Exception Request - Booking #${bookingId}`,\n          description: `User is requesting an exception to cancel confirmed booking #${bookingId}.\\n\\nJustification: ${justification}`,\n          category: 'cancellation_exception',\n          priority: 'medium',\n          status: 'open'\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        success: true,\n        ticketId: ticket.id\n      };\n    } catch (error) {\n      console.error('Error creating cancellation exception request:', error);\n      return {\n        success: false,\n        error: 'Failed to submit cancellation exception request'\n      };\n    }\n  }\n\n  /**\n   * Grant cancellation exception (admin function)\n   */\n  static async grantCancellationException(bookingId: number): Promise<CancellationResult> {\n    try {\n      // Set special flag to allow cancellation\n      const { error: updateError } = await supabase\n        .from('ride_bookings')\n        .update({ can_cancel_after_confirm: true })\n        .eq('id', bookingId);\n\n      if (updateError) throw updateError;\n\n      return {\n        success: true,\n        refunded: false,\n        reason: 'Cancellation exception granted. Booking can now be cancelled.'\n      };\n    } catch (error) {\n      console.error('Error granting cancellation exception:', error);\n      return {\n        success: false,\n        refunded: false,\n        error: 'Failed to grant cancellation exception'\n      };\n    }\n  }\n\n  /**\n   * Send cancellation message to chat\n   */\n  private static async sendCancellationMessage(\n    bookingId: number, \n    rideId: number, \n    userId: string, \n    reason: string,\n    refundAmount?: number,\n    cancellationFee?: number\n  ): Promise<void> {\n    try {\n      let messageText = '';\n      \n      switch (reason) {\n        case 'passenger_cancelled':\n          if (refundAmount && refundAmount > 0) {\n            if (cancellationFee && cancellationFee > 0) {\n              messageText = `Passenger cancelled the booking. Refund of $${refundAmount.toFixed(2)} will be processed (cancellation fee: $${cancellationFee.toFixed(2)}).`;\n            } else {\n              messageText = `Passenger cancelled the booking. Full refund of $${refundAmount.toFixed(2)} will be processed.`;\n            }\n          } else {\n            messageText = 'Passenger cancelled the booking. No refund applicable.';\n          }\n          break;\n        case 'driver_cancelled':\n          messageText = 'Driver cancelled the ride. Full refund will be processed automatically.';\n          break;\n        case 'timeout':\n          messageText = 'Booking expired due to no driver response. Full refund processed automatically.';\n          break;\n        default:\n          messageText = 'Booking has been cancelled.';\n      }\n\n      await supabase\n        .from('messages')\n        .insert({\n          booking_id: bookingId,\n          sender_id: userId,\n          message: messageText,\n          is_system_message: true\n        });\n\n    } catch (error) {\n      console.error('Error sending cancellation message:', error);\n    }\n  }\n\n  /**\n   * Check if ride is completed (for determining if cancellation is still possible)\n   */\n  static async isRideCompleted(rideId: number): Promise<boolean> {\n    try {\n      const { data: ride } = await supabase\n        .from('rides')\n        .select('status, departure_time, arrival_time')\n        .eq('id', rideId)\n        .single();\n\n      if (!ride) return false;\n\n      // Check if ride is marked as completed\n      if (ride.status === 'completed') return true;\n\n      // Check if enough time has passed since departure\n      const now = new Date();\n      const departureTime = new Date(ride.departure_time);\n      const hoursPassedSinceDeparture = (now.getTime() - departureTime.getTime()) / (1000 * 60 * 60);\n\n      // Consider ride completed if more than 6 hours have passed since departure\n      // (assuming most rides don't take longer than 6 hours)\n      return hoursPassedSinceDeparture > 6;\n\n    } catch (error) {\n      console.error('Error checking ride completion:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Process automatic refunds based on cancellation policies\n   * Called by scheduled jobs or triggered events\n   */\n  static async processAutomaticRefunds(): Promise<void> {\n    try {\n      // Find all pending bookings that have expired\n      const { data: expiredBookings } = await supabase\n        .from('ride_bookings')\n        .select(`\n          *,\n          rides (departure_time, driver_id)\n        `)\n        .eq('status', 'pending')\n        .lt('response_deadline', new Date().toISOString());\n\n      for (const booking of expiredBookings || []) {\n        await PaymentHoldService.refundPaymentHold(booking.id, 'timeout');\n      }\n\n      console.log(`Processed ${expiredBookings?.length || 0} expired booking refunds`);\n    } catch (error) {\n      console.error('Error processing automatic refunds:', error);\n    }\n  }\n}"],"names":["BookingPolicyService","bookingId","userId","booking","error","supabase","isPassenger","isDriver","now","hoursUntilDeparture","refundData","totalAmount","refundPercentage","refundAmount","cancellationFee","eligibility","bookingError","refundResult","PaymentHoldService","updateError","payment","justification","ticket","rideId","reason","messageText","ride","departureTime","expiredBookings"],"mappings":"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"}